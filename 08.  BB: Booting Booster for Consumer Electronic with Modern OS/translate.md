# BB: 가전 제품을 위한 현대 OS를 탑재한 부팅 부스터 
## BB: Booting Booster for Consumer Electronics with Modern OS

## Abstract
스마트폰과 태블릿 이후 TV나 디지털 카메라 등의 가전 제품 등에 다양한 컴퓨팅 플랫폼이 빠르고 널리 퍼진다. 
이런 장치에서 빠른 부팅은 중요한 요구사항이다: PC나 스마트폰과 달리 카메라나 TV 등을 켜는데 10초가량을 기다리는것은 용납되지 않는다.
게다가, 이 장치들의 소프트웨어 플랫폼은 기존의 컴퓨팅 장치와 유사한 서비스를 제공하기 위해 기존의 컴퓨팅 장치만큼 풍부해졌다.
결과적으로, 모든 필수 OS 서비스를 시작하기 위한 부팅 절차, 하드웨어 컴포넌트, 어플리케이션의 양은 점점 증가하고 대부분의 소비자가 참을 수 없을만큼의 시간이 걸릴 수 있다.
부팅을 가속화하기 위해 본 논문은 Booting Booster(BB)를 제안한다. 이는 모든 2015년의 삼성 스마트 TV에 사용되었고, 리눅스 기반의 Tizen OS를 실행한다.
BB는 초기 유저 공간 OS 서비스와 어플리케이션을 실행하고 booting-critical task를 식별 및 고립시키고 중요하지 않은 작업을 지연시키며 많은 작업을 병렬로 실행할 수 있게 함으로써 모든 유저 프로세스의 라이프 사이클을 관리하는 리눅스의 init scheme을 다룬다. 
BB는 삼성 스마트 TV 2015 모델들에서 hibernation나 suspend-to-RAM의 사용 없이 cold 부팅 시간 3.5초(BB 없이 모든 상용화된 최적화를 진행했을 때 8.1초와 비교하여)를 성취하며 성공적으로 전개되었다.
이 성공적인 배치 후에 우리는 소스 코드를 발표([http://opensource.samsung.com/](http://opensource.samsung.com/))했고 BB는 오픈 소스 OS Tizen([http://tizen.org/](http://tizen.org/))에 포함될 것이다.   

## 1. Introduction
소비자들은 TV를 포함하는 가전제품에의 사용자 입력에 대해 더 짧은 응답시간을 원한다. 
이는 주로 더 빠르고 새로운 하드웨어를 사용함으로 달성된다.
예외는 TV의 부팅 시간이다. 
수십년 전에, 채널을 변경하고 수 초 안에 그림을 볼 수 있었다(1974년도에 5초 ~ 1994년에 1초).
오늘날, 현대 스마트 TV에는 수 초의 시간이 요구된다.
이러한 퇴화는 주로 소프트웨어 패키지 수의 증가와 복잡성으로 인해 발생한다. 
가전 제품은 사용자에게 빠르게 응답해야하고 항상 켜져있지 않는다 - 예를 들어 TV와 카메라의 부팅 시간은 중요한 성능 지표이다. 
TV의 경우, 사용자들은 즉시 채널을 변경하고 그림을 보기를 원한다. 
디지털 카메라의 경우, 사용자들은 사진을 즉시 촬영하기를 원한다; 그렇지 않으면 사용자들은 장면을 놓치게 될 것이다. 
우리는 이 연구에서 Linux 기반의 Tizen을 작동하는 최신 smart TV의 상당한 부팅 시간 감소를 설명한다.  

일반적인 목적의 OS에서 가전 제품의 부팅 시간을 줄이기 위해 (스마트 장치로 알려진), 개발자들은 hibernation와 suspend-to-RAM를 포함한 다양한 방식을 시도했다.
지속적으로 전력 공급하는 환경에서는 사용자가 기기가 종료되어있다고 간주하는 동안 모든 하드웨어의 상태를 RAM에 저장하고 RAM이 켜져 있는 상태인 suspend-to-RAM를 사용할 수 있다(대부분의 스마트폰이 이렇게 한다).
하지만, 많은 소비자들은 전력 소비에 민감하여 TV를 사용하지 않을 때 플러그를 제거하고(suspend-to-RAM 종료), TV의 느린 부팅 속도에 불평한다. 
우리는 최고사양의 TV에 위와 같은 suspend-to-RAM를 적용했었고, 부팅 시간에 대한 컴플레인을 받았다.  

다른 인기있는 접근은 hibernation로, 이는 휘발성 메모리(DRAM)를 포함한 모든 상태를 비휘발성 메모리(플래시 메모리 및 하드디스크)에 저장하고 부팅 과정에 상태를 복구하는 방식이다. 
우리는 부팅 시간을 써드파티 어플리케이션을 지원하지 않는 NX-300 에서 2초 이하로 감소시켰다.
만일 부팅 이후 초기 상태가 써드파티 어플리케이션과 유저의 커스터마이징으로 인해 일정하지 않다면 저장된 hibernation 이미지는 업데이트 되어야 하고, 이는 많은 중요한 문제를 일으킨다.
hibernation 이미지는 종료 시에 과도한 시간을 요구하고, 따라서 사용자는 즉시 장치를 재시작하거나 언플러그 할 수 없다.
따라서 스마트 TV의 경우, 콜드 부팅(전통적인 부팅)성능이 중요하다.   

스마트 TV는 주로 더 오랜 부팅 시간을 겪는다.
예를 들어, 몇몇 스마트 TV는 20초 혹은 40초의 부팅 시간을 갖는다. 
이 시간은 20년 전 보다 느리다!
위에서 언급한 대로, 사용자는 TV를 언플러그 한다; 따라서, suspend-to-RAM는 상당히 효과적인 방법임에도 불구하고 제한된 방법이다; 예를 들어, suspend-to-RAM 기반의 "Instant-On" 기능은 2초보다 짧다.
그러므로, 최근의 Tizen TV의 주 성능 목표는 빠른 콜드 부팅 시간이다: 플러그를 꽂고 스마트 TV를 켜는데 까지 3.5초.   

이 논문은 적은 수의(저자의 경우 3명) 시스템 소프트웨어 개발자들로 따라가기에는 너무 방대하고 역동적으로 변하는 시스템 소프트웨어 패키지의 이해 없이 개발자들이 어떻게 부팅 성능을 개선했는지를 보여준다.
콜드 부팅은 부트 로더에서 시작하고, 이는 완료 이후에 커널을 load 한다. 
커널 부팅의 완료 이후에, 커널은 OS 서비스와 시작 프로그램을 포함한 미리 정의된 소프트웨어 패키지를 load하고 초기화하는 init scheme을 load한다. 
주변 하드웨어 구성 요소와 OS 서비스의 수가 지속적으로 증가함에 따라, 유저 공간 및 커널 모두의 부팅 task 크기 또한 지속적으로 증가한다.
끝없이 증가하는 부팅시에 초기화 되어야 하는 하드웨어와 소프트웨어 컴포넌트를 대처하기 위해 개발자들은 최근 가전 제품에 사용 가능한 멀티 코어 CPU를 활용한 병렬화를 적용하려 시도했다.
예를 들어, 삼성 JS9500 시리즈 TV는 8개의 CPU 코어를 가진다.  

불행히도, 부팅 과정의 명령은 각각 독립적이지 않고, 작업간의 의존성은 극도로 복잡하다. 
의존의 복잡성은 특히 OS 서비스에서 문제가 되는데 이는 서비스의 수와 그들 간의 의존 관계의 수가 개발 중에 상당히 증가할 수 있기 때문이다.
우리는 OS 서비스의 수가 약 100개에서 시작하여 몇 달 만에 두배가 되는 사례를 목격했다.
다른 측면으로, 이런 거대한 프로젝트에서 OS에 대해 제한적인 이해를 하고 있는 많은 개발자의 개입은 초기화 단계을 증가시킨다.
결과적으로, 고유의 소프트웨어 컴포넌트를 최적화 혹은 안정화하기 위해, 개발자들은 종종 과도하고 불필요하게 순서와 의존성을 선언한다.
현대 리눅스 초기화 절차에는 많은 다른 종류의 의존성이 선언될 수 있다; 예를 들어, "나는 A 가 필요하다", "B가 나를 필요로 한다", "나는 C 이후에 부팅되기를 원치 않는다" 또는 "나는 파일 경로 D가 사용가능한 이후에 부팅되고 싶다" 등.
동시에, 소프트웨어 플랫폼의 컴포넌트 사이의 관계와 컴포넌트의  수는 적은 수의 시스템 소프트웨어 개발자(저자들)들이 직접, 특히 플랫폼이 동적으로 매일, 실제로 매 시간마다 동료 개발자에 의해 변경되는 상황에서 해결하기에는 너무 거대하다.   

이 논문은 어떻게 우리가 수많은 소프트웨어 컴포넌트와 복잡한 의존성을 가진 스마트 TV의 소프트웨어 컴포넌트를 직접 작업하지 않고 콜드 부팅 시간을 상당히 줄였는지를 나타낸다.
제안 메커니즘은 최신 리눅스 커널 버전(3.10 혹은 이후)과 표준 초기화 절차(v208 혹은 이후)를 사용하는 리눅스 플랫폼에 대해 일반적이다.
우리의 주된 기여는 다음과 같다:
 - 우리는 Booting Booster(BB) 메커니즘을 개발했다. 이는 다음과 같은 방식을 통해 중요한 시작 프로그램과 서비스를 상당히 빠르게 초기화한다: 
   - 부팅 시간에 결정적인 요인이 아닌 작업들을 지연시킴
   - 부팅 완료를 위해 중요한 작업들을 자동으로 식별하고, 고립시키고, 우선순위를 책정함.
   - 부팅 시간 기반 동기화 메커니즘과 더 많은 작업을 병렬 처리하는 향상된 병행성(모듈화 및 지연) 사용.
   - 로딩, 서비스 구성 파일의 파싱과 같은 반복적인 작업을 빌드시에 전처리.
   - Infrastructure에서 나타나는 병목 현상의 성능을 향상시킴  

 - 세션 4에서 나타낸 대로 몇몇 삼성 스마트 TV 2014년 모델에서 향상된 성능을 검증한 후 모든 2015년 모델에 성공적으로 BB를 적용했다. 해당 소스코드는 [http://opensource.samsung.com/](http://opensource.samsung.com/)에서 사용 가능하고, 이는 이후 버전의 오픈소스 OS Tizen에 포함될 것이다. 이는 [http//tizen.org/](http//tizen.org/).  

이후 논문의 구성은 다음과 같다.
Section 2에서는 더 자세한 배경과 부팅 시간을 줄이기 위한 이전 연구와 최신 OS를 사용하는 가전 제품에 대한 전통적인 콜드 부팅의 필요성을 설명한다.
Section 3은 제안 기법 BB가 어떻게 구현되었는지 설명한다.
Section 4는 BB의 검증 기법과 실험 결과를 보여준다.
Section 5에서 BB의 문제점을 논의하고 Section 6에서 결론을 맺는다.  

## 2. Background and Related Work
Linux를 기반으로 한 현대 가전 제품은 일반적으로 Linux 컴퓨터를 부팅하는 것과 다르지 않다.
그림 1은 이 연구 이전의 Tizen TV의 시간 정보와 부팅 과정을 나타낸다.
이전 연구의 최적화 기술과 상업적 단계의 소프트웨어 패키지 최적화 기술은 이미 그림 1에서 보여준 부팅 과정에 적용되어 있다.  

전원을 켜는 신호를 받으면, CPU는 내부 읽기 전용 메모리(ROM)에 저장되어있는 명령어를 사용해 부팅 과정을 시작한다.
이 명령어들은 CPU가 다른 명령어들의 집합(부트로더)을 스토리지 장치의 미리 지정된 장소에서 읽어들고 부트로더를 실행하도록 한다.
부트로더는 커널을 시작하는 데 필요한 하드웨어 장치를 실행하고, 커널을 로드하고 실행한다.  

커널이 초기화 된 후((2.4절) 예를 들어 커널 컴포넌트와 장치 드라이버가 실행되었고 유저 공간 컴포넌트를 실행할 준비가 됨) 커널은 init 프로세스를 호출한다. 이는 최초의 유저 프로세스이고 시스템이 종료될 때 까지 실행되는 데몬이다.
init 프로세스가 없으면, 커널은 커널 패닉으로 시스템을 정지시킨다.
init 프로세스는 부팅과 종료 시퀀스를 포함한 유저 프로세스 관리를 책임진다.
그러므로 init 프로세스를 최적화 하는것과 커널은 특히, 많은 현대 init 과정이 그러하듯 init 프로세스가 복잡하고 무거울 경우에 부팅 시간을 감소시키는 시작점이 된다.  

부팅 완료의 정의는 장치의 종류에 따라 다를 수 있다.
TV의 경우, 우리는 부팅완료를 1) 재생중인 채널의 화면과 소리가 재생될 때 그리고 2) 리모컨의 입력에 대해 응답할때;예를 들어 채널 변경 둘 모두 동작할 때로 정의했다.
카메라의 경우 렌즈와 센서가 장면을 촬영할 준비가 되고 디스플레이가 렌즈가 무엇을 보고 있는지 보여주고 있을 때 부팅이 완료된다.
휴대전화는 종종 사용자가 전화를 걸 수 있으면 부팅 완료로 고려된다.   

### 2.1 Suspend and Restore
우리는 가전제품에 두 가지 중단 및 복원 접근 방식을 적용했다: hibernation 기반의 스냅샷 부팅과 suspend-to-RAM.
중단 및 복원 접근방식은 시스템이 대부분의 부팅 과정을 스킵하도록 해준다.
hibernation의 복구 매커니즘은 부트로더에도 구현될 수 있다(삼성 NX-300M). suspend-to-RAM의 복구 메커니즘은 어플리케이션 프로세서가 부트로더를 스킵하기 위해 내부 ROM에 종종 구현된다(최신의 삼성 Exynos 시리즈).  

써드파티 어플리케이션 혹은 어플리케이션 스토어가 없는 기존 가전제품의 경우 리눅스 기반 장치에서도 스냅샷 부팅은 효과적이다. 
예를 들어, 스냅샷 부팅을 통해 리눅스 기반의 Tizen OS(Tizen store 미포함)로 구동하는 NX-300M 카메라의 경우 우리는 1초 가량의 부팅 시간을 달성했다.
이런 장치들은 부팅 이후 최초 상태에서 제한된 변화를 가진다. 즉, 사전에 로드된 공장 스냅샷 이미지를 사용할 수 있다.
만일 스마트 TV나 스마트폰에서와 같이 사용자가 써드파티 어플리케이션과 서비스를 설치할 수 있다면, 사전에 로드된 스냅샷 이미지는 쓸모없어지고, 장치는 실행시 이미지를 새로 생성해야 한다.
하지만, 사용자는 언제든 전원 플러그를 뽑거나 배터리를 뽑을 수 있고(이미지 생성 과정 방해), 스냅샷 이미지를 생성하는것은 시간이 오래 걸리는데, 이 시간동안 사용자는 장치를 이용할 수 없다.
어플리케이션 설치 혹은 종료 중에 수십초 동안(1분 이상일 경우) 응답이 없을 경우 이는 수십 초의 느린 부팅보다 훨씬 나쁘다.
게다가, DRAM의 사이즈가 증가함에 따라, 스냅샷 부팅은 많은 시간이 걸린다.
예를 들어, 휴대전화를 위한 가장발전된 스토리지인 갤럭시 S6 내부의 플래시 미디어 UFS(universial flash storage) 2.0은 300 MiB/s 의 속도로 순차 읽기가 가능하고, 이는 3GiB의(갤럭시 S6의 DRAM 크기) 데이터를 읽기 위해 10초의 시간이 필요함을 의미한다.  

suspend-to-RAM는 많은 가전제품에 적용되어 있다: 스마트폰, TV, 카메라(NX300M은 스냅샷 부팅 및 suspend-to-RAM 모두 사용), 시계.
suspend-to-RAM의 중요한 요구사항은 suspend-to-RAM 중에 장치에 전원 공급이 유지되어야 한다는 것이다.
하지만, 많은 사용자가 TV의 전원을 빈번하게 제거하고, suspend-to-RAM가 종료되어 느린 부팅으로 불평한다.
TV에 배터리를 넣는 방법은 추가적인 비용을 발생시키고 개발자로 하여금 전력 최적화를 개발하게 만든다. 따라서 해당 TV는 오랜 시간동안 종료되어 있어야 할 것이다.
다른 이슈는 일부 저예산의 TV 모델의 suspend-to-RAM 모드를 지원하지 않고, 여전히 범용적인 목적의 OS(Tizen)을 사용하고, 부팅 시간 요구사항이 크게 다르지 않다는 것이다.
따라서, 우리는 TV의 경우(또한 다른 플러그를 사용하는 가전제품), suspend-to-RAM에 의지할 수 없고, 따라서 우리는 우리는 콜드 부팅(비어있는 RAM을 통한 전통 부팅 방법)을 충분히 빠르게 해야 한다.  

다른 suspend-to-RAM 기반 접근은 즉시 조용하게 부팅(화면은 꺼진 상태 유지) 만일 TV에 전원이 들어오면 부팅 후 사용자가 파워 버튼을 누를 때 까지 대기한다. 
불행이도 이 아이디어는 거절되었는데, 이런 행위는 유럽 연합의 규제에 위배되기 때문이다. 
이 규제에 따르면, TV의 대기 상태 전력 소모는 1W 를 초과할 수 없다.
활동하는 스마트 TV 어플리케이션 프로세서는 1W 를 넘는 전력을 소모한다.   

### 2.2 Non-Volatile RAM (NVRAM) Based Approaches
Tim Bird는 부팅을 가속하기 위해 eXcution-In-Place를 NVRAM에 적용하는 기법을 제안했다.
시스템은 NVRAM를 사용하여 전원 종료 상태에서 즉시 준비가 되는데, 이는 상태가 전원이 종료된 동안 보존되기 때문이다.  

MRAM, PRAM, RRAM과 같은 DRAM만큼 빠른 NVRAM의 도입은 이런 접근을 가능하게 한다. 
하지만, 고밀도 및 고성능 NVRAM은 대량 생산하기에는 너무 비싸다.
적당한 고성능 NVRAM은 현재에는 오직 수십 MiB만을 제공한다: 16MiB MRAM은 20달러이다. 
인텔과 마이크론은 그들의 3D CrossPoint memory 대량 생산 계획을 발표했고, 이는 바이트 단위의 주소 지정이 가능하고 고밀도에 비휘발성이며 기존의 flash 장치보다 빠르지만 DRAM보다는 느리다. 
(적어도 DRAM만큼) 수용 가능한 고성능, 고밀도의 NVRAM은 현재에 그리고 근미래에는 사용 불가능하기 때문에 NVRAM 기술은 우리의 연구에서 배제한다.  

### 2.3 Commpression
플래시 메모리의 I/O 처리량은 가전 제품 부팅의 주된 병목이었다.
따라서, 압축은 부팅을 가속화 하기 위해 널리 채택된다. 
하지만, 압축은 거의 도움이 되지 않는데, 이는 플래시의 I/O 처리량이 압축을 해제하는 처리량을 초과하기 때문이다. 
갤럭시 S6의 경우 8개의 모든 코어를 가동하는 것으로 35 MiB/s의 압축해제 처리량을 제공하는데, 플래시 스토리지의 경우 300 MiB/s의 순차 읽기 처리량을 제공한다.  

### 2.4 Kernel Booting 
커널 자체로의 복잡도는 빠른 커널 부팅의 주된 장애물이다: 장치의 수, 장치의 드라이버 그리고 커널의 서브시스템.
커널 바이너리의 크기(10 MiB)는 부팅 시간의 주된 요인이 아니다.
커널 복잡도는 가전제품의 지속적인 소프트웨어의 발전(스마트 장치들로 알려진)과 주변 기기를 추가하려는 경향으로 인해 지속적으로 증가되었다.
예를 들어, 삼성 스마트 TV 2015 모델은 408개의 커널 모듈(.ko 파일)을 가지고 있다.  

우리는 또한 기존의 커널 최적화 방법을 적용했다.
이러한 최적화로, 우리는 커널 초기화의 상당 부분을 지연시키는 광범위한 커널 모듈화 뿐만 아니라 디버깅, 추적, 로깅, 프로파일링 메커니즘과 같은 불필요한 커널 컴포넌트들을 식별하고 제거했다.
이러한 향상은 커널 부팅 시간을 6.127초에서 0.698초로 줄였고, 이는  제안하는 BB 이전의 기본 성능이다.  

### 2.5 Booting of user Space with Init Schemes
그림 2는 Tizen TV의 부팅을 위해 init 과정(systemd)에서 처리되는 136개의 서비스들간의 의존 관계를 보여준다.
게다가, 하나의 서비스는 다중 프로세스(보통 세개 정도)를 포함한다; 예를 들어, D-Bus IPC 서비스는 세개의 프로세스를 가진다. 
하나의 제품을 위한 하나의 fork에서 서비스의 수는 몇 달 만에 136개에서 250개 이상으로 치솟았다.
이는 고객으로부터의 많은 추가적인 요구사항, 콘텐츠 제공자, 네트워크 오퍼레이터 그리고 일반 장치 및 공급업체를 대상으로 하는 "메인라인" OS 제조업체 때문이다.
예를 들어, 몇몇 콘텐츠 제공자는 그들의 디지털 권리 관리(DRM) 솔루션을 내장해야 하는데, 이는 오픈소스가 될 수 없다; 따라서 오픈소스 커뮤니티는 이러한 컴포넌트를 수락하지 않는다.   

의존성의 복잡성은 부팅 시간 최적화의 주된 장애물이다.
만일 시스템 관리자가 하나의 서비스를 일찍 시작하기 위해 우선순위나 의존성을 조정함으로 시작 시간을 변경하면 다른 서비스들의 시작 시간 또한 상당히 달라질 것이고, 이는 전체 부팅 시간에 원치 않는 부작용을 초래한다.
이런 복잡성의 다른 문제점은 부팅 과정의 비결정적 행동이다.
부팅 과정에는 많은 방법이 존재하고, 많은 초기화되어야하는 서비스와 희소한 종속 관계가 있다.
물론, 하나의 서비스의 초기화 시간은 일정하지 않고, 특히 네트워크 응답이나 사용자 입력이 필요할 경우 그러하다.
부팅 시간 최적화를 위한 시스템 관리자들의 가장 심각한 골칫거리는 서비스와 그들의 관계가 버전이 바뀔 때 마다 동적으로 변경된다는 것이다. 
관리자들은 정적 소프트웨어 구성 요소를 다루는 것이 아니라 상용화에 문제가 있어서 동료 개발자에 의해 지속적으로 업데이트되는 구성 요소를 다루고 있다.  

Init Scheme은 BSD init의 출현 이후 부팅 시 OS를 올바르게 초기화 하기 위해 지속적으로 진화되어 왔다.
BSD init 이후 최초에 널리 채택된 init scheme인 rcS는 병렬성이 없었다; 다시 말해, 오직 하나의 서비스가 한번에 초기화 되었다.
리눅스 시작 스크립트(예를 들어 etc/init.d/rcS)는 init 데몬이 시작 시에 다른 추가적인 실행할 수 있도록 허용한다.
이는 보통 추가적인 파일 시스템을 마운트하거고 데몬들을 실행하는데 쓰인다.
멀티 프로세서 시스템의 소개와 함께, rcS는 _fork_ 와 _execve_ 시스템 콜을 통해 병행성을 지원하도록 변화했다.
이후, rcS는 POSIX 쓰레드 라이브러리를 통해 멀티 쓰레드 구조를 도입했고, 이는 병렬 처리를 지원하는 동시에 rcS 스크립트의 다중 쓰레드 프로그램의 효율성을 향상시켰다.  

init scheme은 최근 유저 공간에서 프로세서 생성 종료뿐만 아니라, CPU 스케줄링, I/O 스케줄링, 메모리 압력을 관리하기 시작했다.
이런 기능은 이전에는 오직 커널에서 관리되었다.
하지만, 커널은 보통 모든 유저 프로세스를 동등하게 처리하고, 각각의 유저 프로세스를 처리할 충분한 정보를 가지지 못한다. 
이러한 격차를 메꾸기 위해 최근의 init scheme에는 각 프로세스의 특성을 기반으로한 정책을 가진 자원 관리 메커니즘이 추가되었다.  

 - **CPU 스케줄링**은 실행되어있는 프로세스들을 POSIX 시스템 콜(_nice()_, _setpriority()_, *sched_setscheduler()*등)을 통해 기본 스케줄링 우선 순위를 설정한다.  
 - **I/O 스케줄링**은 *ioprio_set()*을 통해 프로세스를 실행하기 위한 I/O 스케줄링 클래스와 I/O 스케줄링 우선순위를 설정한다.   
 - **Memory pressure** 관리는 유저 프로세스들 간의 우선순위를 조정하고, 메모리가 부족해지면 메인 메모리에서 추방할 프로세스를 결정한다.   
 - **유저 프로세스 생성 및 종료** 기능은 init scheme이 모든 유저 프로세스의 생명 주기를 관리할 수 있게 한다.  

그림 1에서 나타낸 바와 같이, 이전 연구에 따라 OS의 유저공간을 실행시키고 장치 드라이버를 초기화하기 위한 시간은 부팅 시간 최적화 이후 대부분의 부팅 시간을 차지한다.
소프트웨어 플랫폼의 복잡성 증가와 주변 기기들의 증가는 부팅 시간 증가에 큰 영향을 미친다.
추가로, 이전 단락에서 나타낸 바와 같이, 유저 공간 프로세스들의 init scheme 에서 요구되는 서비스의 증가하는 복잡도는 부팅 시간을 지연시키는데 영향을 미친다.
이는 현대의 init scheme이 시작 순서를 포함한 모든 의존 관계를 고려해야 하기 때문이고, 서비스의 시작 시간은 빌드시에 결정되지 않기 때문이다; 즉, 유저가 추가적인 서비스를 설치할 수 있고, 서비스는 업데이트 될 수 있으며(네트워크 관리자 및 제조업체는 유저 모르게 서비스를 업데이트 할 수 있음), 또는 서비스가 스스로 업데이트 할 수 있다.  

#### 2.5.1 Out-of-Order Mechanisms
Out-of-Order Mechanisms은 서비스 전에 사용되도록 의도된 서비스의 완료에 대한 고려 없이 서비스를 실행한다: BSDinit, SysVinit, eINIT, Lanched, Svscan, Windows service control manager, Busybox-init.
다시 말해, out-of-order mechanisms 때문에 어떠한 서비스던지 특정 시간에 즉시 시작될 수 있다. 
Out-of-order mechenisms의 주된 결점은 의존 관계와 서비스의 시작 시간이 실행 중에 변경 가능할 때(다시 말해 빌드 시에 결정되지 않음), 서비스 시작 지연 시간이 결정적이지 않을때, 그리고 서비스 또는 서비스간의 관계가 변경될 때 부팅 과정을 올바르게 처리할 수 없다는 것이다. 
위에서 언급한 것과 같은 단점을 현대 가전제품들이 가지고 있다.  

이런 단점을 완화시키기 위해 out-of-order mechanisms는 최근에 서비스에 필요한 다른 서비스에서 만들어진 특정 경로가 생성될때 까지 서비스 시작을 지연시키는 path-check 메소드를 채택했다. 
그 결과, 최근 out-of-order 메커니즘은 지정 및 수정된 서비스에 대해 순서가 변경되었다.
하지만, 이런 메소드는 비결정적 가능성과 의존 관계를 가진 모든 OS 서비스에서 수정을 요구하는데, 이는 우리의 시스템과 같은 의존 관계가 직접 수정하기에 너무 복잡하면 실현이 불가능하다.  

#### 2.5.2 In-Order Mechanisms
_Advanced Boot Script_, _OpenRC_, _Up-start_, _systemd_ 와 같은 In-Order Mechanisms는 의존하는 서비스를 실행하기 전에 요구되는 서비스 실행을 완료해야 한다.
In-Order Mechanisms는 병렬적으로 상호 의존적이지 않은 유저 프로세스를 호출하는 동안 정확한 서비스의 시작 절차를 보장한다.
In-Order Mechanisms는 서비스가 의존하는 서비스를 완전히 설명할 때 부정확한 부팅에 대한 가능성을 완전하게 제거한다.  

Advanced Boot Script는 병렬성과 의존 선언을 지원하는 in-order init scheme을 제안했다.
Advanced Boot Script는 소프트웨어 패키지 개발자가 서비스의 단방향 의존성을 선언할 수 있도록(예를 들어, "나는 서비스 A가 나 이전에 초기화 되어야 한다") 허용하고, 그들이 같은 그룹에 속하고 의존성 선언을 훼손하지 않는다면 병렬로 서비스를 초기화한다.
Advanced Boot Script의 부팅 시간 최적화에 대한 한계는 다음과 같다: 1) run-levels를 기반으로하는데, 이는 각 프로그램의 부팅시 실행되어야 하는 그룹이고, run-levels는 전체 순서이다. 다른 run-levels의 프로그램은 병렬적으로 실행될 수 없다. 2) 이는 시스템 개발자(혹은 서버 시스템의 관리자)가 더 빠른 부팅을 위해 프로그램에 우선순위를 정하는 것을 허용하지 않는다. 
Advanced Boot Script는 정의된 의존성 선언에 따라 올바른 부팅 순서를 보장하기 위하기 때문이다.
이는 run-levels의 실행 명령을 병렬적으로 실행하거나 서비스간의 우선순위를 표시하는것을 허용하지 않는다.  

더 진화된 in-order scheme인 _systemd_ 는 타이젠과 다른 주류 리눅스에 표준 init scheme으로 널리 수용되었다: Fedora, Red Hat Enterprise Linux, CentOS, Debian, Ubuntu, Megeia, Arch Linux, CoreOS, Slackware, SUSE Linux Enterpirse, openSUSE.
의존성, 시작 우선순위 및 상태, 자원 관리 정책, 모니터링 및 복구 시스템, 그리고 각각의 서비스를 위한 다른 관계된 메커니즘은 서비스 각각의 파일에 선언되어 있고, 부팅시에 분석되어 제공된다.  

현재 사실상 기본 리눅스 init scheme인 run-levels를 제거한 _systemd_ 는 더 많은 작업을 병렬로 처리할 수 있다.
_systemd_ (공식적으로, 이는 lower case "s"와 시작한다)는 또한 개발자가 더 복잡한 서비스를 표현하는것을 허용한다.
예를 들어, 한 서비스는 "I am needed by service A.", "I need to be started before service B", 혹은 "I need to be started if /tmp/foo is created" 와 같이 선언될 수 있다.
_systemd_ 는 또한 실행 시 서비스를 감시하고 관리하기 위한 메커니즘과 유저 프로세스의 자원 관리 서비스를 제공한다.
시스템 및 서비스 개발자를 위한 다양한 도구를 사용하여 시스템을 조정하고 미세 조정할 가능성이 크다.   

#### 2.5.3 Issues of Modern Init Schemes
부팅 시간을 줄이기 위해서, 우리는 많은 프로세스를 동시에 실행하는것을 시도했고, 이는 멀티코어 아키텍처에 의해 지원되는 병렬성을 활용하며 심지어 I/O 집약적 작업에서도 모든 코어를 완전하게 활성화하는것을 목적으로 한다. 
부팅 시간에 가능한 많은 프로세스를 실행하는데 주된 문제점은 다른 전제 조건이 되는 프로세스가 필수 서비스를 제공할 준비가 되어있지 않을 가능성이다; 만일 문제가 생길 가능성을 무시함으로 부팅 순서를 망치거나 혹은 완전한 부팅 과정을 보장하는데 시간이 든다면, 가전제품의 부팅 시간을 향상시키기에 매우 어렵다.
그림 2는 타이젠 OS 상용화 이전의 이런 의존성을 보여주는데, 이는 사실상 서비스의 수를 거의 두배로 늘린다.
Init scheme은 의존성을 따름으로 올바른 부팅 과정을 보장하는 것이 요구된다.   

이러한 의존성은 더 복잡해졌고, 부팅 과정을 최적화하는것은 극도로 어려워졌는데, 이는 하나의 의존 관계가 직접적으로는 두 서비스의 실행 시간에 영향을 미치고, 간접적으로 다른 많은 서비스들의 실행시간에 영향을 미치기 때문이다. 
그림 3은 하나의 의존관계에 대한 업데이트가 전체 부팅 과정에 어떻게 영향을 미치는지 보여준다.
그림에서 하나의 그룹은 OS에서 비슷한 특성과 실행 순서를 가지며 주로 개발자 팀에서 처리되는 부팅시에 실행되어야 하는 서비스를 나타낸다.
그림에서, 새로 추가되는 그룹 b의 서비스 a에서 요구되는(서비스 c는 서비스 a보다 일찍 실행되어야 한다고 선언한다) 그룹 a의 서비스 c는 전체 그룹 C에 영향을 미치고, 그룹 b에 영향을 미쳐 프로세스를 병렬로 시작할 확률을 줄인다.   

그림 3은 개발자 팀에 할당된 그룹의 서비스가 그룹으로(또는 가까운 일정에) 유지된다고 보장할 수 없음을 이야기한다.
그러면, 상응하는 개발자 팀은 그들 서비스의 부팅 과정을 효과적으로 관리할 수 없다; 그들의 서비스 순서는 또다른 팀에 의해 쉽게 방해된다.
많은 수의 이런 예외가 자라서(250개 이상의 OS 서비스, 다양한 사전 로드된 애플리케이션, 지역, 운영자, 디스플레이 패널 크기 또는 시장 세그먼트별로 다양한 모델, 그리고 많은 개발자로 인해 빠르게 성장함을 보장한다), 하나의 서비스의 그룹은 분열되고 상응하는 개발자들은 그들 서비스의 시작 시간을 보장할 수 없다.
TV 개발 중에, 우리는 가장 중요한 OS 서비스 D-Bus(타이젠의 표준 내부 프로세스 통신(IPC, Inter-Process Communication) 서비스) 데몬이 다른 서비스의 요구사항 및 사양 변화로 인해 시작 시간에 대한 다양한 어려움을 가지는 것을 목격했다.
우리는 이런 내용에 대해 4.2절에서 좀 더 자세히 묘사했다.  

_systemd_ 와 다른 현대 in-order 메커니즘의 추가적인 단점은 init scheme 자체의 복잡성 그리고 이전 단락에서 언급한 효과를 악화시키는 역동성 때문이다.
개발자에게 많은 도구와 표현 기능을 제공하는것은 주로 많은 악용 가능성을 초래한다.
우리는 서비스 개발자들이 다른 사름들보다 높은 우선순위와 많은 자원을 가지려는 경향을 보이고 결과적으로 전체 성능에 부정적으로 작용하는 많은 사례를 목격했다; 다시 말해, 부팅 시간.
그들은 또한 자신의 서비스의 정확성을 위해 종종 불필요한 의존성을 추가하고, 이는 불필요한 프로세스 호출을 초래하거나, 심지어 재귀하는 의존성을 만든다. 
스마트 TV의 250개가 넘는 OS 서비스가 동작하는 초기 상태에, 시스템 개발자들은 충분한 지식을 갖고있지 못하다. 
따라서, 시스템 개발자들은 특히 서비스 개발자들이 제품이 개발될 때 까지 매일 사양을 변경하는 때에 이런 이슈에 효과적으로 대처하지 못한다.
때때로, 그들은 제품이 출시된 이후에도 사양을 변경한다!  

반면, 병렬적으로 복잡한 의존 관계를 가진 여러 작업을 수행하는것(OS 서비스를 시작하는것)은 반드시 최적화되어야 하는 매우 어려운 작업이다.
또한, 컴퓨터 시스템의 전통적인 콜드부팅 시간을 몇 초까지 줄이는것은 별로 주목을 받지 못하는데, 이는 현재 컴퓨터 시스템의 주류 OS는 짧은 부팅 시간을 요구하지 않거나, 대체 부팅 메커니즘을 사용할 수 있기 때문이다(snapshot boooting). 다시말해, PC, 서버, 태블릿 혹은 스마트폰의 유저들은 그들의 장치를 켜진 채로 두거나, 부팅 시간을 신경쓰지 않고 가전 제품의 기존 임베디드 장치는 대체 부팅 메커니즘을 사용할 수 있다.   

그러므로, 나타나는 서비스의 실행시간을 최적화 하는것은 어렵다: 원격 제어 신호를 수신하고 그에 따라 하드웨어를 제어하는 데 필요한 방송 채널 및 서비스를 보여주는 응용 프로그램.
다시말해, 더 많은 서비스의 의존성이 복잡해질수록, 더 많은 서비스들이 지연된다.
더 나쁜점은, 복잡해진 비 결정적 의존성 구조 및 역동성은 인스턴스마다 부팅 시간이 달라진다는 것이다.   

이 논문에서, 우리는 부팅 시간에 치명적인 mount, socket, D-Bus, 최상위 서비스와 같은 서비스를 고립시키는 Booting Booster Group Isolator를 추가하여 증가한 의존성의 복잡도를 해결하는 BB를 소개한다.
게다가, BB의 시스템 아키텍처는 부팅 시간을 향상시키기 위해 서버 환경뿐만 아니라 부팅 시간이 중요한 가전 제품을 처리하기 위해 기존의 init scheme _systemd_ 를 획기적으로 경량화한다.
BB는 모든 2015년의 삼성 스마트 TV 제품의 OS인 타이젠의 표준 init scheme인 _systemd_ 를 기반으로한다.
제안 접근법은 부팅 메커니즘 전체(리눅스 커널, _systemd_)에 종사하는 시스템 개발자에게 OS 서비스의 지식을 요구하지 않으며, dependency-based init scheme의 주요 단점을 해결한다. 
우리의 시스템(삼성 스마트 TV 2015 모델들)은 이전의 메커니즘에 직교한다; 다시말해, suspend-to-RAM 기술은 여전히 추가적으로 적용된다.  

## 3. Design and Implementation
본 단락에서, 우리는 빠른 부팅을 위한 시스템이 어떻게 구현되어 있는지를 나타낸다.
그림 4는 타이젠에서 만들어진 제안 기법 BB의 전체 구조를 나타낸다.
BB는 다음 세가지 엔진으로 구성된다: _Core Engine_, _Boot-up Engine_, _Service Engine_.
각 기능별로 감소된 시간에 대한 상세한 분석은 section 4에서 나타낸다.
추상적으로, 우리의 작업은 리눅스 시스템의 부팅 시퀀스를 다음과 같이 가속화했다: a) BB 그룹을 식별하고 BB그룹에 고립된 환경을 제공한다; b) 커널에 내재된 특성 모듈화 지연, _systemd_ 내부의 부팅에 중요하지 않은 작업 실행 지연 그리고 부팅에 중요하지 않은 작업 실행 지연; c) 가속화된 RCU와 지연된 임무들에 의해 가능하게된 향상된 병렬 실행.
### 3.1 Core Engine
__Core Engine__ 은 커널 공간의 BB 컴포넌트로 구성된다.
_On-demand Modularizer_ 는 지연시키고 동시에 이후에 init scheme을 시작하는데 필요로 하지 않는 하위 시스템을 시작하는 내장된 커널 컴포넌트를 모듈화한다.
부팅 후 USB(Universal Serial Bus)와 같은 장치 관련 사용자 응용 프로그램의 시작시 내장 커널 모듈을 실행하기 위해 기본 부팅이 ​​완료될 때까지 중요하지 않은 내장 커널 모듈의 초기화를 지연시킨다.
외부 커널 모듈 없이 내장 커널 모듈과 함께 _init call_을 기반으로 하는 지연된 초기화 접근을 적용함으로써, 우리는 외부 모듈에서 메모리로 로드하기 위해 요구되는 시스템 콜(예를 들어, open, read, close)의 수를 극적으로 줄였다.
_Core Engie_ 은 오직 요구되는 크기의 메모리만 초기화하고 나머지 공간의 초기화는 지연시킴으로, 큰 메모리 공간을 가진 현대 컴퓨팅 장치에서 지나치게 오래 걸릴수도 있는 유저 프로세스를 시작하는 시간을 줄였다.
_RCU Bootser_는 선택적으로 일반적으로 커널 구성 요소 간의 공유 변수를 보호하기 위해 사용되는 동기화 메커니즘인 _Read-Copy-Update(RCU)_ 를 부팅한다.
RCU는 특히 공유 변수를 읽는데 효과적이고, 이는 부팅시 상당히 빈번하게 사용된다. 다시 말해, 이는 부팅시 주된 병목의 원인이 된다.
RCU의 병목은 또한, 3.2절의 실험 결과로도 나타난다; 다시 말해, 부팅 시간의 RCU 오버헤드는 _Core Engine_ 의 _RCU Booster_ 를 사용해 상당히 감소된다.    

RCU는 선택적으로 가속화되는데 왜냐하면 만일 RCU를 사용하는 threads가 0 혹은 1이라면 전통적인 메커니즘이 더 나은 성능을 보인다; 일반적으로 부팅 완료 이후는 0 혹은 1이다.
전통적인 RCU 메커니즘은 메커니즘의 critical section을 ticket spin lock을 통해 보호하는데, 이는 부팅 시 critical section의 lock을 획득하려 하는 쓰레드가 여러 개일 경우 비효율적일 수 있다.
RCU 부스터의 구현(알고리즘 2)은 ticket spin lock의 필요성을 memory barriers와 mutexes를 채용함으로 대체했고, 대기중인 쓰레드들을 spin하지 않고 sleep 하도록 만들었다. 다시말해 다른 쓰레드들의 cpu를 해제했다.
한편으로, 위에서 언급한 대로, RCU 부스터는 몇몇 쓰레드가 동시에 lock을 요청하면 기존에 비해 더 높은 CPU 부하를 가지고, 따라서 우리는 선택적으로 RCU 부스터를 사용한다.   

그림 5(b)는 제안 시스템의 순차적인 명령의 흐름을 보여준다.
커널이 첫 번째 유저 프로세스(init scheme, __systemd__)를 실행할 준비가 되면, 커널의 _Core Engine_ 는 첫 번째 사용자 프로세스를 로드하기 전에 먼저 실행되는 메모리 초기화를 제외한 하위 구성 요소를 시작한다.
더 구체적으로, _On-demand Modularizer_ 은 지연이 결정된 커널 모듈들을 내장하고 RCU 부스터가 초기화된다.

### 3.2 Boot-up Engine
__Bootup Engine__ 은 스스로의 시작 서비스를 구동하기 위해 유저 공간 BB 컴포넌트들로 구성되어 있다. 
이는 systemd에 위치되어 있는데, 이는 사실상의 리눅스 표준 init scheme이다. 
_Boot-up Engine_ 은 더 빠른 _systemd_ 의 초기화를 담당하고, 유저 공간 서비스가 실행되기 전 _systemd_ 의 최초 명령으로써 커널 공간 _Core Engine_ 의 기능을 활성화한다(예를 들어, 그림 6의 (b)Boot-up Engine #1과 Boot-up Engine #2).
_RCU Booster Control_ 은 유저공간의 agent로써 _RCU Booster_ 를 활성화 및 비활성화 한다.
_Deferred Executor_ 은 OS 서비스를 시작하는데 필요로 하지 않는 init scheme 서브 모듈을 지연시키고 병렬적으로 실행하여 init scheme의 초기화를 가속한다.
_On-demand Modularizer Control_ 은 _On-demand Modularizer_ 로써 모듈화된 컴포넌트가 OS 서비스 혹은 어플리케이션에서 요구될 때 유저 공간 on-demand manager를 시작하도록 허용한다.  

_systemd_ 가 시작되면, Boot-up Engine은 _systemd_ 의 최초 모듈로써 시작된다.
_RCU Booster Control_ 은 Boot-up Engine이 시작되고난 직후, _RCU Booster_ 를 활성화하고, 일반적으로 부팅 과정이 완료되면 비활성화한다.
_RCU Booster_ 를 비활성화 하기 위한 조건은 관리자의 결정에 따라 구성 가능하다; 다시 말해, 부팅에 많이 사용되는 RCU 기능을 가속화하기 위한 CPU 오버헤드를 감당할 수 있는지.
_systemd_ 의 부팅 과정을 나타낸 그림 5(a)는 _RCU Booster_ 로 부팅할 때 더 많은 작업이 병렬로 빠르게 시작됨을 나타낸다. 
그림에서 x 축은 시간을, y축을 위에서 아래로 시작되는 OS 서비스를 보여준다.
가속화된 경우는 더 많은 작업이 빠르게 실행되는것을 보여준다; 다시 말해, 아래쪽에 있는 서비스가 더 일찍 시작된다(x축의 원점에 가깝다).  

_Deffer Executor_ 을 사용하여 _Boot-up Engine_ 은 OS 서비스를 실행하는데 필요하지 않은 _systemd_ 작업을 시스템이 부팅 완료라고 인식할 때 까지 지연시킨다; 다시 말해, 사용자가 TV를 보고있다.
이 경우, 필수적인 서비스는 방송 채널들을 확인하고 리모컨 입력에 응답할 최소 OS 서비스로 정의된다.
따라서, _systemd_ 는 필요한 작업만 실행하고 OS 서비스를 더 일찍 시작할 수 있다.
지연된 _systemd_ 작업은 커널 모듈, 호스트 이름, 컴퓨터 ID, 루프백 장치, 테스트 및 디버그 목적의 디렉터리를 포함하는 로깅 및 설정 절차이다.
부팅하는 동안 사실상 읽기 전용이고 나중에 루트 파일 시스템이 쓰기 가능한 저널 모드를 지연 작업으로 다시 마운트할 수 있기 때문에 root 파일시스템의 EXT4 저널 모드를 활성화 또한 지연되었다.  

### 3.3 Service Engine
__Service Engine__ 은 부팅에 중요한 서비스와 중요하지 않은 서비스를 제어하기 위해 유저 공간 BB 컴포넌트로 구성되어 있다.
이는 시스템 관리자를 위한 도구, _Booting Booster Group Isolator_ , _Booting Booster Manager_ 를 가지고 있다. 이는 _systemd_ 에 구현되어 있고, _sysyemd_ 내부의 _Service Engine_ 이 유저 공간 서비스를 사용할 준비가 되면 부팅 과정을 가속화한다.
_systemd_ 가 유저 공간 서비스를 실행할 준비가 되면(_Boot-up Engine_ 은 이 전에 완전히 로드되고 잘 동작), 동시에, 그림 5(c) 에서 "_Booting Booster(BB) Group_"로 표기된 _Booting Booster Group Isolator_ 부팅에 중요한 프로세스의 그롭을 정의한다. 이는 사용자가 시스템을 사용할 준비가 되었다고 인식할 수 있도록 하는 OS 서비스이다; 다시말해, TV 채널을 보여주는데 요구되는 서비스, 리모컨 입력을 처리하는 서비스, 첫 번째 어플리케이션을 실행하는데 필요한 서비스.
부팅 과정을 의존성 분석 이후 격리하는것의 동기는 개발자들이 자체 서비스의 우선순위를 올려 전체 시스템을 손상시키는것을 막기 위해서이다.
2015 삼성 스마트 TV 모델의 BB 그룹에는 7개의 서비스가 있다(다시말해, mount, socket, dbus, tuner, hdmi, demux, fasttv).
_Booting Booster Manager_ 은 BB 그룹의 프로세스를 실행하고 우선순위를 책정하고 부팅을 빠르게 완료하기 위한 그룹의 프로세스들을 관리한다.  

서비스 엔진의 도구들은 시스템 관리자가 부팅 시간을 최적화하는것을 돕는다: _Service Analyzer_ 그리고 _Pre-parser_.
_Service Analyzer_ 는 소프트웨어 패키지의 구성 파일을 읽음으로써 서비스간의 관계를 조사하고, call-graph 생성기(Codeviz, Graphviz) 를 기반으로 올바르지 않은 관계를 보고한다(다시 말해, 원형 의존성 혹은 모순되는 요구사항).
_Pre-parser_ 는 _systemd_ 로 실행된 수백 가지의 서비스로 부터 쓰여진 파싱 서비스 구성 파일의 부팅 시간 오버헤드를 줄인다.
_Pre-parser_ 는 이런 서비스 구성 파일을 미리 분석하고 _systemd_ 가 사전 준비된 데이터를 읽고 부팅 시 구성 파일 읽기와 구문 분석을 건너뛸 수 있도록 한다.  

하나의 소프트웨어 패키지 구성 파일은 Listing 1에 나타난다. 
"Before= socket.service" 표현은 socket.service 유닛이 Myapp.service가 활성화 되기 전까지 실행될 수 없음을 의미한다.
만일, 부팅시에 둘이 동시에 활성화된다면, 각 서비스의 실행 시간은 두 서비스의 의존관계로 결정된다.
서비스의 실행 시간을 결정하는 세 가지의 유닛 타입이 있다.
첫 번째, "Type=Simple" 은 이후의 서비스가 이전의 서비스가 시작한 후 곧바로 시작된다는 것을 의미한다. 
이 타입은 서비스간에 독립적인 작업을 실행하는데 사용될 수 있다.
두 번째, "Type=Foring" 은 "ExecStart=" 의 포크 시스템 호출이 실행되는 즉시 socket.service를 시작할 수 있음을 의미한다.
마지막으로, "Type=oneshot" 은 socket.service 가 "ExecStart=" 상태가 fork 시스템 콜로 완료된 후 곧바로 실행될 수 있음을 의미한다.
WantedBy=multi-user.target” 상태는 Myapp.service 유닛이 multi-user.target group에 속한다는 것을 의미한다.  

_Service Engine_ 이 시작하면, _Booting Booster Group Isolator_ 는 부팅에 중요한 역할을 하는 _BB Group_ 서비스를 식별한다. 
_Booting Booster Group Isolator_ 은 이러한 서비스를 관계를 부팅 완료의 정의에 대한 의존성을 분석함으로 식별한다.
고립된 _BB Group_ 은 상응하는 서비스가 그룹 외의 서비스와 그룹 외부에서 정의된 의존성 요구사항 혹은 우선순위를 무시하도록 허용한다.
_BB Group_ 를 사용하여, 시스템 관리자는 다른 OS 서비스나 어플리케이션을 개발하면서 부팅 시간을 일관적으로 유지할 수 있고, 부팅에 중요한 작업에만 집중할 수 있다.
예를 들어, 메신저 서비스가 방송 신호 관리 서비스(부팅에 중요한 작업) 이전에 실행되어야 한다고 정의되어 있더라도, 방송 신호 관리 서비스는 메신저 서비스에 영향을 받지 않는다; 방송 신호 관리 서비스와 그것이 요구하는 서비스가 메신저 서비스를 필요로 하지 않느 한.  

그러면, _Booting Booster Manager_ 은 그룹 내부의 프로세스들을 실행하기 시작한다.
이 시점에, BB 그룹에 속하지 않은 프로세스들은 그룹에 속한 프로세스와 마찬가지로, _systemd_ 에 의해 실행된다.
_Booting Booster Manager_ 는 빠른 부팅을 BB Group에 속하는 프로세스들의 위해 우선순위를 책정한다.
결과적으로, 그룹 내부에 존재하지 않은 프로세스들은 연산 자원을 사용할 수 없을 경우, 지연된다.   

## 4. Evaluation
우리는 2014년에 발행된 삼성 UHD 스마트 TV 모델(UE48H6200)의 실험 결과를 보여준다.
이의 후속 모델인 모든 2015년 삼성 스마트 TV 모델들처럼, UE48H6200 은 타이젠 2.3 TV profile 과 Linux 3.10 커널, _systemd_ v 208 init에서 동작한다.
UE48H6200은 Cortex A9 CPU 코어 4개와 1Gib DRAM, GPU, 비디오 및 오디오 처리 유닛, 8GiB eMMC 플래시 스토리지, 네트워크 인터페이스, 48인치 UHD 디스플레이 패널을 가진 어플리케이션 프로세서를 가진다.
해당 eMMC의 성능은 SSD와 비교할 수 없지만, HDD와 견줄만 하다.
UE48H6200의 eMMC는 117MiB/s의 순차 읽기 성능과 37MiB/s의 랜덤 읽기 성능을 갖는다.
Samsung SSD 850 Evo 500 GB SSD는 515MiB/s의 순차 읽기 성능, 379 MiB/s의 랜덤 읽기 성능을 가진다.
eagate Barracuda 3TB HDD(ST3000DM001, 2011년 출시)는 165MB/s 의 순차 읽기 성능과 65MB/s의 랜덤 읽기 성능을 가진다.  

시스템의 소스코드는 [http://opensource.samsung.com/](http://opensource.samsung.com/)에서 모델 이름 “U***H62**”로 사용 가능하다.
비록 우리가 2014 TV 모델 UE48H6200 하나의 실험 결과만 나타내지만, 제시하는 연구 BB는 같은 하드웨어 플랫폼을 가진 많은 스마트 TV 2014 모델에 널리 채택되었다.
게다가, 모든 2015 삼성 스마트 TV 모델은 같은 버전의 타이젠, 커널, 그리고 본 논문에서 제안하는 기법 BB를 사용하며, 성능적 요구를 만족한다.  

사실상의 리눅스 표준 init scheme _systemd_ 는 대부분의 스마트 TV, 그리고 데스크톱과 서버 시스템에도 사용된다. 
국제 스마트 TV 시장은 주로(절반 이상) 세 가지 주요 제조사가 점유하고 있다: 삼성(Tizen), LG(WebOS), Sony(CE Linux). 
세 가지 제조사의 주요 스마트 TV OS는 리눅스 커널과 _systemd_ 를 사용하기 때문에, 제안 기법 BB는 다른 두 OS 에도 쉽게 이식될 수 있다.
스마트 TV 그룹 뿐만 아니라, BB는 많은 다양한 장치에도 이식될 수 있다: 휴대전화(삼성 Z1, Z3, 2015년), wearable 장치(Gear 시리즈, 2014년), 디지털 카메라(NX300 이후의 NX 시리즈, 2013년), 다른 가전젬품(에어컨, 냉장고, 로봇 청소기, 2015년).
따라서, BB는 매끄럽고 쉽게 넓은 범위의 가전 제품에 적용될 수 있다.   

### 4.1 Experimental Results
그림 6은 BB와 기존 방식 둘 모두의 시스템 전체의 부팅 시간에 대한 실험 결과를 나타낸다.
시간은 어플리케이션 프로세스에 통합된 나노초의 정밀도를 가지는 고 정밀 하드웨어 타이머를 통해 측정되었고, 이는 전원 시그널과 함께 시작한다.
실험은 BB가 8.1초에서 3.5초로 약 57%의 부팅 시간을 감소시킴을 나타낸다.  

분석을 위해, 우리는 그림 6에 나타난 것 처럼, 전체 부팅 과정의 세 가지 주요 단계의 지연성을 측정했다.
우리는 또한, 기존의 세 가지 주요 단계와 BB의 세 가지 엔진으로 나누어 각 단계별로 비교 분석한다.
두 번째 엔진인 _Boot-up Engine_ 이 이후의 두 주요 단계에서 실행되기 때문에, _Boot-up Engine_ 의 분석은 그림에 나타난 것 처럼 두 부분으로 나누어진다. 
다음의 리스트에, 우리는 그림 6에서 나타난 것 처럼, 제안 기법의 특정 메소드로 인한 지연 감소에 대해 설명한다.  

 __1. Kernel initialization (a):__ _Core Engine_ 은 커널 초기화 지연을 메모리 초기화(370->110 ms)를 통해 698 ms 에서 403 ms로 감소시키고 루트 파일시스템 마운팅(100->75 ms) 시간을 감소시켰다.  
 __2. Init initialization (b):__ _Boot-up Engine_ 의 먼저 부분은 init을 초기화한다.
 _Boot-up Engine_ 은 부팅에 필수적이지 않은 다양한 작업을 지연시킴으로 init 초기화를 195ms 에서 71ms로 감소시켰다.
 지연된 작업은 그림 6(b)에 나타난 "enable logging scheme" (28 ms), "setup kernel module" (28 ms), "setup hostname" (13 ms), "setup machine ID" (9 ms), "setup loopback device" (17 ms) 그리고 "test directory" (29 ms) 이다.
 전체적으로 우리는 보이는 오버헤드 없이 총 124ms 분량의 작업을 지연시켰다.  
 __3. Running services & applications in parallel (c)+(d):__ 나중 부분의 _Boot-up Engine_ 그리고 _Service Engine_ 은 서비스 및 어플리케이션을 병렬적으로 실행하는 과정에 포함된다. 커널 공간의 _RCU Booster Control_ 은 그림 6 (c)의  _RCU Booster_ 로 나타난다: 2289 ms -> 461 ms.
 _Deferred Executor_ 은 496 ms를, _On-demand Modularizer_ 과 _On-demand Modularizer Control_ 은 428 ms를 단축했다. 
 그림 6 (b)는 _Pre-paser_ 이 "loading services"에서 150 ms를 , "parsing service dependencies"에서 231 ms를 단축함을 보여주고 _Booting Booster Group Isolator_ 와 _Manager_ 가 부팅에 핵심인 작업들을 고립시킴으로 1011 ms를 단축시킴을 보여준다.   

전체적으로, _Booting Booster Group Isolator_, _Booting Booster Manager_(1101 ms 단축) 그리고 _RCU Booster_ and _RCU Booster Control_ (1828 ms 단축)의 동기화 메커니즘 최적화는 부팅 지연을 크게 감소시켰다.   

### 4.2 How Booting Booster Group Isolation Works
그림 7은 _Booting Booster Group Isolator_ 의 부분적인 실행과 기존 방식에서 "dbus.service"(표준 IPC 메커니즘) 그리고 "var.mount"(/var 디렉토리 마운트)의 실행 시간에 중점을 둔 실험 결과를 나타낸다.
두 서비스 모두 부팅에 핵심적이고, "dbus.service"는 "var.mount"의 완료에 따라 결정된다. 
"dbus.service"가 사실상 모든 타이젠의 서비스 및 어플리케이션에 필수적인 서비스이기 때문에, 가능한 빨리 실행되는 것이 권장된다. 
"dbus.service"의 실행 시간이 상당히 빨라짐을 나타낸다.
결과는 "var.mount"를 고립시킴으로 "dbus.service"의 실행 시간이 상당히 향상되었음을 보여준다: 450 ms 에서 195 ms로.  

그림 7의 왼편은 기존과의 부팅 절차를 비교하여 보여준다. 
오른 편은 기존에 비해 부팅 과정이 가속화됨을 보여준다.
그림에서, 1© 은 “var.mount” 그리고 2© 는 “dbus.service”이다. 
가속화된 부팅 절차의 경우, 우리는 부팅 시 BB Group을 인식하여 부팅에 중요한 서비스를 자동으로 식별하고 BB Group을 최상위 작업으로 실행하는 _Booting Booster Group Isolator_ 를 완전하게 사용 가능할 때 그룹에 추가되었을 부팅에 중요한 다른 서비스 없이 수동적으로 "var.mount"를 고립된 BB 그룹에 추가했다.
"var.mount" 및 하위 서비스 "dbus.service"의 효과를 검증하기 위해, 우리는 _Booting Booster Group Isolator_ 가 "dbus.service"를 사용할 수 없도록 하고, 수동으로 "var.mount"를 부팅에 중요한 작업으로 설정했다.  

시스템 관리자가 개발자에게 그렇게 하지 말것을 요구해도, 서비스 및 어플리케이션 개발자는 "var.mount"와 서비스간의 순서 의존성을 추가했고,(최종 버전에는 약 수십개 정도) 그래서 서비스가 더 빠르게 실행되어 더 최적화가 된 것 처럼 보이게 한다.
한편으로, "var.mount"가 유일한 경우가 아니다; 몇몇 다른 부팅에 핵심적인 같은 현상을 겪고 있는 작업들은 자동으로 BB에 의해 선언된다.
이러한 환경에서, 우리는 부팅에 핵심적인 프로세스를 다른 프로세스와 분리하여 미리 부팅하는것을 성공하여 시간에 맞게 부팅할 수 있었다.   

### 4.3 Performance Trade Off
_RCU Booster_ 는 하나의 RCU를 동기화 하기 위해 쓰레드의 경쟁이 없을 경우, 기존의 RCU 메커니즘과 비교하여 더 많은 CPU 자원을 소모한다.
이는 _RCU Booster_ 가 부팅 중에 여러 쓰레드가 RCU를 사용하려고 할 때 CPU를 효율적으로 사용하기 위해 spinlock 대신 pre-emptible mutexes를 사용하기 때문이다. 
_RCU Booster_ 는 유저공간에 __sysfs__ 파일시스템을 이용하여 동적 컨트롤 인터페이스를 제공하고, 따라서 유저 공간의 _RCU Booster Control_ 의 유저 공간은 _RCU Booster_ 을 동적으로 활성화 혹은 비활성화 할 수 있다.
일반적인 실행 시간(부팅과 같은 과정을 제외하고)에서, 주로 하나의 RCU를 동기화하려고 두개의 쓰레드가 경쟁하지 않고, 이러한 경우 spinlock이 mutex 보다 비용이 낮다.  

BB는 부팅에 중요하지 않은 작업은 지연시키는 경향이 있다.
부팅 완료 이후 지연된 작업이 실행되고, 지연된 작업은 다른 부팅 작업과 함께 수행되어야 한다.
게다가, (다시 말해, _systemd_ 의 실행 동안)이전 단계에서 실행된 지연된 작업은 지연된 작업을 병렬적으로 실행되는것을 허용한다.
하지만, 부팅 시간에 영향을 미치지 않는다고 해도, 이런 시스템 서비스를 지연하는 것은 그들을 의존하는 어플리케이션에게 추가적인 실행 딜레이를 발생시킨다. 
다행히도, 한 번 하나의 어플리케이션이 지연된 작업의 시작을 유발한다면, 지연된 작업은 더 이상 추가적인 어플리케이션 실행에 지연을 발생시키지 않고, 하나의 어플리케이션이 보통 두 개 이상의 지연된 작업을 의존하지 않는다. 
실험은 작업 지연의 오버헤드 성능이 무시할 만 함을 나타낸다: 평균적으로 15 ms 이하, 그리고 지연된 서비스 작업을 의존하는 어플리케이션의 표준 편차는 1.5% 이하.    

## 5. Discussion
__Dependency on open source packages.__ 
가전 제품 소프트웨어 플랫폼은 많은 수의 오픈소스 소프트웨어 패키지를 포함한다; 타이젠의 경우 수백개를 가진다.
제조사들은 오픈소스 패키지를 사용하는데, 이는 개발 및 유지보수 비용을 줄이고 새로운 기술을 적은 노력으로 사용할 수 있고, 외부 개발자의 기여를 허용하기 때문이다. 
반면, 다양한 오픈소스 소프트웨어 패키지는 의존성의 복잡도를 증가시킨다.  

작업에 독립적인 실험 결과는 OS 컴포넌트 간의 의존성을 단절하는 것이 부팅 속도를 최적화 하는데에 중요함을 나타낸다. 
소프트웨어 단편화는 주로 우리가 이런 오픈소스 패키지를 의존 관계를 자르기 위해 수정할 때 나타난다.
대부분의 _upstream_ 패키지는 _upstream_ 오픈 소스 소프트웨어 패키지의 사용자 중 하나일 뿐인 단일 소프트웨어 플랫폼과 독립적으로 발전한다.
따라서, 우리는 _upstream_ 이 너무 많이 발전되기 전에 _upstream_ 에 우리의 변경 사항을 병합하거나, 로컬 _downstream_ fork가  _upstream_ 으로 정규적으로 업데이트되도록 해야한다.
장기적으로, 전자가 더 나은 방법이다; 하지만, 수백개의 이러한 패키지는 다른 분야의 장치 카테고리로 인해 변경될 것이고, 이는 종종 이를 성취하기가 너무 어렵다.  

__Usage and effectiveness of BB Group.__ 우리는 부팅에 핵심적인 프로세스를 고립시키는 것을 제안했고, 이는 _BB Group_ 을 통해 더 짧은 부팅 시간을 성취했다. 
제안 기법은 소프트웨어 패키지의 수정을 요구하지 않는다.
이는 오직 부팅 완료를 정의하는 어플리케이션의 목록만을 요구한다; 다시 말해, TV에서 TV를 송출하기 위한 어플리케이션.
고립은 부팅에 핵심적이지 않은 작업들이 지연되도록 하고, CPU가 어플리케이션의 부팅 완료시 정의된 부팅에 핵심적인 작업을 불러오도록 한다.
고립과 지연이 없으면, 많은 부팅에 핵심적인 작업이 CPU 코어가 핵심적이지 않은 작업에 쓰이고 있을 때 기다려야 한다.  

__Tackle dependencies directly.__ 이상적으로, 불필요한 의존 관계를 식별하거나 의존성을 줄이기 위해 소프트웨어를 수정하는 것으로 프로세스간의 최소 의존 관계가 유지된다.
의존 관계를 줄이는것은 시스템이 병렬성을 활성화하고 부팅 완료를 위한 더 빠른 방법을 찾을 수 있도록 하며, 심지어 불필요한 소프트웨어 패키지를 식별할 수 있게 한다.
하지만, 정의된 의존성을 잘못 제거하는 것은 부팅 과정에 문제를 일으킬 수 있다; 혹은 더 나쁘게는 테스터가 알지 못하는 숨겨진 방식으로 문제를 일으킬 수 있고, 이는 개발사에게는 악몽이다.
위에서 언급한 대로, 이는 시스템 관리자가 다른 소프트웨어 패키지를 이해하고 업데이트 하는 것은 극히 어려운데, 이는 단순히 너무 많은 소프트웨어 플랫폼이 존재하기 때문이다; 예를 들어, 타이젠에는 외부 어플리케이션과 공급업체 및 운영자별 패키지를 제외하고 약 1000개의 패키지들이 존재한다.
게다가, 몇몇 개발자들은 그들 자신의 패키지가 더 안전하게 하기 위해 추가적인 의존성을 선언하거나, 성능을 개선하기 위해 부적절한 순서를 설정하는 경향이 있다.
그러므로, 최소 의존성 구조를 식별하기 위해, 우리는 가능한 모든 시퀀스를 실험하며 사실상 그들이 선언한 것을 무시해야 한다.  

우리는 모든 추가적인 의존성과 순서에 대한 정의를 확인하려 했다.
실제로, 변화의 폭은 소수의 관리자가 처리하기에는 상당히 컸고, 실제로 모든 소프트웨어 패키지는 관리자에게 친숙하지 않았다.
게다가, 많은 개발자들이 새로운 의존성의 추가가 아닌, 새로운 소프트웨어 패키지를 시스템에 추가하고 있다는 것을 알려주는 것조차 신경쓰지 않았다.
이런 상황을 더 악화시키는 것은, 출시일이 상당히 가까운 날 까지도 이러한 변화가 매일 일어났다는 것이다; 때때로, OS에 대한 변경이 제품이 출시된 이후에도 일어났다.   

다행히, 대부분의 가전제품의 경우, 부팅 완료는 부팅 시에 OS로 부터 실행되는 모든 유저 프로세스가 아닌 몇몇 유저 프로세스의 완료로 정의된다.
심지어, 이런 몇몇 프로세스는 오직 몇 개의 OS 서비스만 요구하고, 이는 프로세스가 _BB Group_ 으로 인해 완전히 고립되어 있는 한, 몇몇의 관리자가 서비스의 종속성을 다룰 수 있게 한다.   

우리는 아직 의존성을 직접적으로 다루지 않았는데, 이는 우리가 다른 친숙하지 않은 소프트웨어 컴포넌트에 대한 분석 없이 부팅 시간을 줄일 수 있었기 때문이다. 
비록, 권장되지는 않지만, 만일 _BB Group_ 의 크기가 성장하면(그리고 당연히 몇 년 내로 성장할 것이다), 의존성의 선언을 확인하고 의존성을 추가 혹은 제거하기 위해 자동화 메커니즘이 요구될 것이다. 
이런 메커니즘은 사소하지 않다; 몇몇 패키지의 소스코드는 심지어 제조사들도 사용할 수 없고, 몇몇 의존성은 직접적으로 보여지지 않는다(파일 경로의 사용 가능성 혹은 파일의 값을 기반으로 하는 의존성).  

__Pre-parser, pre-link, and pre-fork__ 는 전처리 메커니즘을 사용하여 연산 자원을 줄인다(시간 및 메모리).
BB의 _Pre-parser_ 는 전체 데이터를 미리 파싱하고 파싱한 데이터를 각 부팅의 인스턴스가 파싱한 데이터를 각 부팅 인스턴스에 대해 다시 파싱하는것을 피하기 위해 파싱된 데이터를 유지함으로써 부팅 시에 모든 서비스 정의(_Systemd_ 유닛 파일)를 파싱하는 CPU 시간을 줄인다.