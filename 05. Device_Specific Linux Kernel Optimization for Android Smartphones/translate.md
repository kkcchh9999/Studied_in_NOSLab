# 안드로이드 스마트폰을 위한 특정 장치 리눅스 커널 최적화
## Device_Specific Linux Kernel Optimization for Android Smartphones

## Abstract
스마트폰을 더 강력하게 만들기 위해, 연구자들은 모바일 시스템과 어플리케이션 성능을 향상시키기 위한 많은 기술을 제안했다.
가장 인기있는 모바일 OS인 안드로이드는 리눅스 커널을 기반으로 만들어 져 있다. 
그러므로, 커널 성능을 최적화 하는 것은 잠재적으로 안드로이드 스마트폰의 성능을 향상시킬 수 있다.  

이 논문에서는, 안드로이드 스마트폰의 장치별 리눅스 커널의 구성을 최적화하는 컴파일러 기반의 접근을 제안한다.
장치의 런타임 feedback을 활용하는 것으로, 우리는 컴파일러가 profile 기반 최적화(Profile-Guided Optimization, PGO)하도록 지시할 수 있고, 특정 장치에 대한 리눅스 커널 이미지 최적화를 제공할 수 있다. 이 이미지는 제조 시 장치와 함께 제공되거나, 나중에 전체 시스템 업데이트에서 릴리즈 될 수 있다.
우리가 아는 한, 이 논문은 성능 향상을 위해 PGO를 안드로이드 스마트폰의 리눅스 커널에 성공적으로 적용한 최초의 연구이다.   

우리는 다른 세 가지의 안드로이드 스마트폰에서 실험을 진행했다: Nexus 5X, Nexus 6, Nexus 5.
결과적으로 각각 평균적인 성능이 11.1%, 4.1%, 9.3% 상승하였다. 
특히, 우리는 멀티쓰레드, 스케줄링, 바인더, 스토리지와 파일시스템 같은 핵심 안드로이드 시스템 컴포넌트의 성능 향상을 관측했다.

## 1. Introduction
스마트폰의 빠른 확산은 모바일 컴퓨팅의 번영을 이뤘다. 
장치의 크기와 배터리 제약으로 인해, 스마트폰의 연산 능력은 데스크탑이나 서버에 비해 아직 제한되어 있다.
더 정교한 어플리케이션을 지원하기 위해, COMET나 Uniport같은 모바일 클라우드 컴퓨팅 기술이 제안되어 강력한 클라우딩 컴퓨팅 인프라를 모바일 장치에 통합했다.
반면, 많은 연구들은 모바일 시스템과 어플리케이션의 성능 최적화를 수행한다.
예를 들어, F2FS는 플래시 스토리지를 위한 파일 시스템 성능을 향상시킨다.
SmartIO는 스마트폰의 iowait 지연을 줄인다. 
PerfChecker는 스마트폰 어플리케이션의 성능 버그를 탐지한다.   

모바일 OS의 가장 높은 점유율을 가지는 안드로이드는 리눅스 커널 기반이다. 
커널 성능은 전체 시스템 효율에서 중요하기 때문에, 리눅스 커널의 성능 최적화는 그 위에서 동작하는 안드로이드 어플리케이션을 가속할 수 있다.
이 논문에서, 우리는 안드로이드 모바일 장치를 위한 기기별 리눅스 커널 최적화를 위해 컴파일러 기반의 접근 즉, PGO를 채택했다.
최적화된 커널을 사용함으로, 우리는 멀티쓰레드, 태스크 스케줄링, 바인더 인터 프로세스 통신, 스토리지와 파일입출력 등의 중요한 안드로이드 시스템 컴포넌트의 성능을 향상시킬 수 있다.   

우리의 이전 연구는 PGO 기술을 사용해 리눅스 커널을 최적화 하는것이 x86 기반의 기기에서 실현 가능한 것을 증명했다. 
이 논문에서는, 우리는 성공적으로 PGO 기술을 안드로이드 스마트폰의 리눅스 커널에 적용했다. 
x86 기반 기기에서 수행한 어플리케이션별 커널 최적화와 다르게, 우리는 안드로이드 스마트폰을 위한 장치별 커널 최적화를 겨냥했다.    

장치별 최적화된 리눅스 커널은 새로운 혹은 기존의 장치에 대해 최적화 될 수 있다.
이는 새로운 장치가 제조될 때 함께 제공될 수 있다.
혹은 기존 장치에 대해, 시스템 업데이트시 제공될 수 있다.
instrumentation된 모바일 장치의 리눅스 커널을 실행 그리고 적절한 profile feedback을 수집함에 의해 우리는 컴파일러, 즉 GCC 에게 향상된 최적화를 수행하고, 각 장치에 최적화된 리눅스 커널 이미지를 생성하도록 지시할 수 있다.  

우리의 주요 기여는 아래와 같다.
 - 컴파일러 기반 접근을 통해 안드로이드 스마트폰을 위한 장치별 리눅스 커널 최적화를 제시한다. 실제 최적화 과정 동안, 유저는 커널에 대해 어떠한 수동적인 수정을 진행할 필요가 없다.
 - 우리는 제안된 최적화를 구현하고, 안드로이드 커널 성능을 측정했다. 세 가지 다른 안드로이드 스마트폰에서 우리의 실험을 기반으로 기본 -02 최적화와 비교했을 때, 우리의 접근은 시스템 성능을 4.1 ~ 11.1% 향상시켰다.
 - 우리가 아는 한, 이 논문은 가장 최초로 속도 향상을 위해 PGO 기술을 안드로이드 스마트폰의 리눅스 커널에 성공적으로 적용했다. 컴파일러 기반의 접근이기 때문에, 다른 안드로이드 시스템 향상 기법에서도 추가적인 성능향상을 위해 해당 기법을 적용할 수 있다.  

이하의 논문은 다음과 같은 순서를 가진다.
Section 2에서는 리눅스 커널을 최적화 하기 위한 PGO와 GCC 최적화에 대한 배경 지식을 다룬다.
Section 3에서는 안드로이드의 리눅스 커널에 대한 상세한 디자인과 구현에 대해 다룬다.
Section 4는 벤치마크와 실험 환경, 다른 스마트폰에서의 실험 결과에 대해 나타낸다.
Section 5는 관련 연구를, Section 6은 결론을 나타낸다.

## 2. Background
### 2.1 Profile-Guided Optimization (PGO)
PGO는 컴파일러 커뮤니티에서 잘 연구되었다. 
제어 흐름 그래프나 하나 이상의 프로그램 실행에서 수집된 표현 값 profile 등의 feedback information을 사용함으로 컴파일러는 자주 실행되는 부분의 최적화에 집중할 수 있다.
PGO는 FireFox, Chrome, GCC itself 같은 대형 오픈소스 프로젝트에 적용되어있고, 5~17% 의 속도 향상을 성취했다.  

전형적인 PGO 프로세스는 다음과 같은 절차를 따른다: 
 - Instrumentation. 컴파일러는 컴파일 중에 profile 정보를 모으기 위해 목표 프로그램을 instrumentation하고, 이는 이후에 최적화에 사용된다. 해당 profile 정보는 제어 흐름 트레이스, 값, 주소 profile 등을 포함한다.  

 - Profile Collection. instrumentation된 목표 프로그램은 profile 정보를 모으기 위해 실행된다. 실행 프로세스는 실제 실행 시나리오를 반영해야 한다.  

 - Optimization. 컴파일러는 목표 프로그램을 최적화 하기 위해 이전 단계에서 수집된 profile 정보를 사용한다. profile 정보는 컴파일러가 branch prediction, basic block reordering, funtion inlining, loop unrolling 등에서 더 나은 결정을 할 수 있도록 돕는다.  

최근 GCC 버전들은 샘플링 기반의 AutoFDO를 지원하고, 이는 프로그램 instrumentation이 필요하지 않다.
이는 인텔 프로세서의 last branch record support를 요구한다.
하지만, 안드로이드 스마트폰은 ARM 프로세서를 사용한다.
따라서 우리는 본 논문에서 AutoFDO를 채택하지 않았다. 

### 2.2 PGO in Linux Kernel
우리는 이전 연구에서 PGO가 x86 기반의 장치(데스크톱이나 서버 등)의 리눅스 커널에 적용할 수 있음을 보여줬고, 그 목표는 어플리케이션별 리눅스 커널 최적화였다. 
목표 어플리케이션이 실행될 때 리눅스 커널에서 instrumentation된 feedback 정보를 수집하고, 그 feedback 정보를 컴파일러 최적화에 사용함으로, 우리는 목표 어플리케이션에 비교적 최적의 성능을 제공하는 최적화된 커널 이미지를 빌드할 수 있었다.
PGO 기술을 리눅스 커널에 적용하기 위해 우리는 아래와 같은 도전을 극복했다: 
 - Enabling kernel instrumentation: 우리는 kernel instrumentation support를 리눅스 커널과 GCC에 추가했고, instrumentation된 커널이 x86 기반의 장치에서 동작할 수 있도록 했다.
 - Collecting kernel profile feedback: 우리는 커널 profile feedback을 수집하고 처리하기 위한 도구를 구현했다. 시작과 종료를 적절히 지정함으로 어플리케이션별 커널 feedback 정보를 수집할 수 있었다. 
 - Choosing correct optimization: 우리는 성능을 향상시키고 코드 길이를 줄이며 신뢰할 수 있게 커널 최적화를 하기 위한 적합한 컴파일러 최적화 옵션을 선택했다.

## 3. Design and Implementation
### 3.1 Challenges
유저 어플리케이션에서 PGO를 사용하는 것은 몇몇 컴파일러 옵션을 활성화하는 것 만큼 쉽고, x86 기반의 장치의 리눅스 커널에서 PGO를 적용하는 것은 이전 연구에서 구현되었고, 안드로이드 스마트폰을 위한 장치별 최적화된 커널을 구현하기 위해 PGO를 채택하는 것은 다음과 같은 새로운 기술적 과제에 직면하게 된다: 
 - Kernel instrumentation: 안드로이드 스마트폰은 일반적으로 레거시 리눅스 버전을 사용한다. 따라서, 우리는 kernel instrumentation support를 backport하고, 안드로이드에서 사용되는 ARM과 ARM64 프로세서 지원을 추가할 필요가 있다.
 - Booting the instrument kernel: 안드로이드의 부팅 절차는 복잡하고, 안드로이드 부트로더는 독점적이기 때문에, instrumentation된 커널의 부팅 문제를 해결하기 위해 블랙박스 테스트 및 리버스 엔지니어링을 수행해야 한다. 
 - Device-specific optimization: 장치별 커널 최적화를 성취하기 위해서, 우리는 먼저 장치별 커널 feedback 정보를 수집해야 한다. 후에, 우리는 안드로이드 스마트폰의 리눅스 커널을 최적화 시키기에 적합한 컴파일러 최적화 옵션을 선택해야 한다.

### 3.2 Design Overview
이전 연구에서, 우리는 성공적으로 PGO를 x86 기반 장치의 리눅스 커널에 적용했다.
PGO를 리눅스 ARM/ARM64 기반 안드로이드 스마트폰의 커널에 적용하기 위해서, 우리는 사용자 어플리케이션과 x86 기반 장치의 리눅스 커널에 PGO를 적용하는것과 비교하여 제안하는 접근법을 그림 1에 나타낸다.  

안드로이드 스마트폰에서 커널 instrumentation하기 위해서는, 우리는 관련된 커널 수정사항을 레거시 리눅스 버전으로 backport 하고, 다른 장치에 대해 instrumented된 커널 이미지를 빌드해야한다.
커널 profile feedback을 수집하기 위해서, 우리는 instrumented 커널을 장치에서 부팅하고, 적절한 툴을 통해 장치별 feedback 정보를 수집하고 처리할 필요가 있다.
커널 최적화를 위해, 우리는 안드로이드 시스템의 리눅스 커널을 위한 컴파일러 최적화 옵션을 채택해야한다.

### 3.3 Kernel Instrumentation
레거시 리눅스 버전에 대한 커널 instrucmentation support 의 backport는 다음과 같이 구성된다. 
 - Udate of the Linux gcov subsystem: gcov 서브시스템은 GCC에서 PGO 기술에 요구하는 제어 흐름 계측을 제공한다. 하지만, 레거시 리눅스 버전은 오직 2011년에 출시된 GCC 4.6 이하의 버전만 지원한다. 우리는 관련된 커널 패치를 backport하고, 최신의 GCC 버전을 지원하도록 gocv 서브시스템을 업데이트한다.
 - Support of ARM and ARM64 architecture: 우리는 안드로이드에서 주로 사용되는 ARM, ARM64의 커널이 instrumenting을 지원하도록 커널 빌드 시스템을 수정한다.
 - Support of data flow instrumentation: 제어 흐름 계측 외에도  GCC의 PGO 기술은 또한 대상 프로그램의 데이터 흐름 계측을 필요로 한다. 우리는 해당 부분을 구현하기 위한 논의를 이전 연구에서 진행했다. 
 - Fixing compilation errors: 안드로이드 스마트폰의 리눅스 버전이 일반적으로 오래되었기 때문에, 커널을 빌드할 때 컴파일 에러가 발생한다. ARM의 경우, `inline` 키워드에서 오류들이 발생할 수 있다. ARM64에서는, GCC의 내장 함수에 관한 에러가 발생할 수 있다. 우리는 이런 에러를 해결하기 위해 커널 소스코드를 수정한다.  

우리가 backporting을 위해 우리가 수정한 소스코드의 수를 요약하여 표 1에서 나타낸다.  

### 3.4 Booting the Instrument Kernel for Profile Collection
안드로이드 스마트폰에서 발생한 커널 feedback 정보를 수집하기 위해서, 우리는 먼저 instrumented 커널을 부팅해야한다.
ARM/ARM64 기반 안드로이드 장치의 부팅 과정은 아래와 같이 요약 가능하다. 
 1. 프로세서가 전원이 공급되고, BootROM에 저장된 주요 부트로더가 실행된다.
 2. BootROM의 공간이 한정적이기 때문에, eMMC에 저장되고 ARM TrustZone를 초기화하는 두 번째 부트로더가 로드되고 실행된다. 
 3. 실제 안드로이드 부트로더는 fastboot 기능을 제공하며, 로드되었고 실행된다.
 4. 리눅스 커널 이미지와 init 램디스크가 로드되고, 안드로이드 시스템이 실행된다. 

안전한 부팅을 보장하기 위해, 각 단계에서 다음 단계에서 로드된 콘텐츠의 전자 서명을 확인한다.
instrumented 커널을 부팅하기 위해, 우리는 커널 이미지를 로드하는 역할을 하는 안드로이드 부트로더를 다루어야 한다.
`fastbooting oem unlock` 명령을 실행함으로써, 우리는 안드로이드 부트로더를 언락하고, 서명 확인을 비활성화한다.
그러면, 우리는 커스텀된 커널 이미지를 장치에서 실행할 수 있게 된다.   

그러나, instrumented 커널은 보통 다른 매개변수로 인해 부팅을 실패하는데, 이는 이미지가 `-O2` 혹은 `Os`로 컴파일된 일반적인 커널 이미지보다 너무 크기 때문이다.
우리는 시행 착오를 통해 파라미터를 조정하고, 적절한 값을 결정 할 필요가 있다.  

블랙 박스 테스트 절차를 보조하기 위해, 우리는 `dd`커맨드를 사용하여 장치의 `aboot` 파티션에서 추출할 수 있는 안드로이드 부트로더에서 리버스 엔지니어링 분석을 수행할 수 있다.
리버스 엔지니어링 분석을 간단히 하기 위해, 대부분의 안드로이드 부트로더가 기반으로 하고 있는 LittleKernel의 소스코드를 인용할 수 있다.  

몇몇 장치들은 파라미터 값이 안드로이드 부트로더에 내장되어 있고, 명령어로 지정될 수 없다.
이런 경우, 우리는 instrumented 커널 이미지 크기를 장치에서 부팅할 수 있을 정도로 줄일 필요가 있다. 
구체적으로, 우리는 선택적 커널 instrumetnation을 채택했다.
리눅스 커널의 핵심 구성 요소만 instrumenting함으로써 스케줄러, 메모리 관리, 파일시스템, 바인더와 같은 이미지 크기를 크게 줄일 수 있었다.  

부팅 문제를 해결한 후, 우리는 instrumented 커널을 장치에서 실행할 수 있었고, feedback 정보를 수집했다.
profile 수집 도구는 쉘스크립트로 구성되어있다.
안드로이드 스마트폰에서 스크립트를 실행하기 위해, 우리는 Debian의 `busybox-static` 패키지를 사용했고, 이는 직접 안드로이드 스마트폰에서 실행할 수 있고, 쉘 스크립트의 실행을 지원하는 정적으로 연결된 ARM과 ARM64 바이너리를 제공한다.  

디바이스별 커널 최적화를 위한 profile feedback을 수집하기 위해, 우리는 instrumented 커널 위에서 실제 실행시간 시나리오를 반영한 안드로이드 어플리케이션 셋을 실행할 필요가 있다.
구체적으로, 우리는 Google Play 또는 기기의 앱 스토어에서 가장 인기있는 어플리케이션들을 선택할 수 있다.

### 3.5 Device-Specific Optimization
선택적인 instrumentation 커널을 사용하는 장치들을 위해서 수집된 feedback 정보는 완전하지 않다. 
feedback 정보가 다루지 않는 커널 소스코드를 위해, 우리는 profile feedback이 존재할 때만 이점이 있는 최적화 옵션을 사용할 수 없게 할 필요가 있다.
구체적으로, 우리는 `-fprofile-use`옵션을 `-fbranch-probabilities`옵션으로 대체할 수 있다.  

우리의 커널 최적화의 컴파일러 기반 접근법은 장치별로 다음과 같은 측면을 따른다: 
 - 다른 장치는 다른 리눅스 버전과 빌드 구성을 사용한다.
 - 다른 장치는 커널 최적화를 위해 다른 GCC 버전을 사용할 수 있다.
 - profiling 중에 수집된 feedback 정보는 장치별로 다르다. 이 feedback 정보는 profile-guided 커널 최적화에 사용된다. 
 - 커널 최적화에 사용된 상세한 컴파일러 옵션은 장치별로 다르다.

## 4. Evaluation
### 4.1 Benchmarks
안드로이드 스마트폰의 시스템 성능을 검증하기 위해서, 우리는 OS 기능을 집중적으로 호출하는 시스템 집약적 벤치마크를 사용해야 한다.
GeekBench 나 AnTuTu 같은 인기있는 벤치마크들은 연산 집약적이고, 따라서 우리의 검증에 부합하지 않는다.
그러므로 우리는 안드로이드 커널의멀티쓰레딩, 스케줄링, 바인더, 스토리지와 파일시스템과같은 핵심 안드로이드 시스템 컴포넌트의 성능을 측정하기 위해 벤치마크를 수집하고 구현했다.  

이전 연구는 안드로이드의 정확한 벤치마킹 성능을 측정하는것은 어렵다고 말한다.
성능 결과를 확실히 하는 것은 유효하고 안정적이고, 우리는 CPU 스케일링 